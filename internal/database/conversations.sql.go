// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: conversations.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const addConversationMember = `-- name: AddConversationMember :exec
INSERT INTO conversation_members (conversation_id, user_id, role)
VALUES ($1, $2, $3)
ON CONFLICT DO NOTHING
`

type AddConversationMemberParams struct {
	ConversationID uuid.UUID  `db:"conversation_id" json:"conversation_id"`
	UserID         uuid.UUID  `db:"user_id" json:"user_id"`
	Role           MemberRole `db:"role" json:"role"`
}

func (q *Queries) AddConversationMember(ctx context.Context, arg AddConversationMemberParams) error {
	_, err := q.exec(ctx, q.addConversationMemberStmt, addConversationMember, arg.ConversationID, arg.UserID, arg.Role)
	return err
}

const createConversation = `-- name: CreateConversation :one
INSERT INTO conversations (created_by, is_group, name)
VALUES ($1, $2, $3)
RETURNING id, is_group, name, created_by, created_at, updated_at
`

type CreateConversationParams struct {
	CreatedBy uuid.UUID      `db:"created_by" json:"created_by"`
	IsGroup   bool           `db:"is_group" json:"is_group"`
	Name      sql.NullString `db:"name" json:"name"`
}

func (q *Queries) CreateConversation(ctx context.Context, arg CreateConversationParams) (Conversation, error) {
	row := q.queryRow(ctx, q.createConversationStmt, createConversation, arg.CreatedBy, arg.IsGroup, arg.Name)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.IsGroup,
		&i.Name,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConversationByID = `-- name: GetConversationByID :one
SELECT id, is_group, name, created_by, created_at, updated_at FROM conversations WHERE id = $1
`

func (q *Queries) GetConversationByID(ctx context.Context, id uuid.UUID) (Conversation, error) {
	row := q.queryRow(ctx, q.getConversationByIDStmt, getConversationByID, id)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.IsGroup,
		&i.Name,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConversationMember = `-- name: GetConversationMember :one
SELECT conversation_id, user_id, role, joined_at, last_read_at FROM conversation_members
WHERE conversation_id = $1 AND user_id = $2
`

type GetConversationMemberParams struct {
	ConversationID uuid.UUID `db:"conversation_id" json:"conversation_id"`
	UserID         uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) GetConversationMember(ctx context.Context, arg GetConversationMemberParams) (ConversationMember, error) {
	row := q.queryRow(ctx, q.getConversationMemberStmt, getConversationMember, arg.ConversationID, arg.UserID)
	var i ConversationMember
	err := row.Scan(
		&i.ConversationID,
		&i.UserID,
		&i.Role,
		&i.JoinedAt,
		&i.LastReadAt,
	)
	return i, err
}

const getConversationMembers = `-- name: GetConversationMembers :many
SELECT user_id, role, joined_at, last_read_at
FROM conversation_members
WHERE conversation_id = $1
ORDER BY joined_at ASC
`

type GetConversationMembersRow struct {
	UserID     uuid.UUID    `db:"user_id" json:"user_id"`
	Role       MemberRole   `db:"role" json:"role"`
	JoinedAt   time.Time    `db:"joined_at" json:"joined_at"`
	LastReadAt sql.NullTime `db:"last_read_at" json:"last_read_at"`
}

func (q *Queries) GetConversationMembers(ctx context.Context, conversationID uuid.UUID) ([]GetConversationMembersRow, error) {
	rows, err := q.query(ctx, q.getConversationMembersStmt, getConversationMembers, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConversationMembersRow
	for rows.Next() {
		var i GetConversationMembersRow
		if err := rows.Scan(
			&i.UserID,
			&i.Role,
			&i.JoinedAt,
			&i.LastReadAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDirectConversation = `-- name: GetDirectConversation :one
SELECT c.id, c.is_group, c.name, c.created_by, c.created_at, c.updated_at FROM conversations c
JOIN conversation_members cm1 ON cm1.conversation_id = c.id AND cm1.user_id = $1
JOIN conversation_members cm2 ON cm2.conversation_id = c.id AND cm2.user_id = $2
WHERE c.is_group = FALSE
LIMIT 1
`

type GetDirectConversationParams struct {
	UserID   uuid.UUID `db:"user_id" json:"user_id"`
	UserID_2 uuid.UUID `db:"user_id_2" json:"user_id_2"`
}

func (q *Queries) GetDirectConversation(ctx context.Context, arg GetDirectConversationParams) (Conversation, error) {
	row := q.queryRow(ctx, q.getDirectConversationStmt, getDirectConversation, arg.UserID, arg.UserID_2)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.IsGroup,
		&i.Name,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFirstAdminOrMember = `-- name: GetFirstAdminOrMember :one
SELECT user_id, role FROM conversation_members
WHERE conversation_id = $1 AND user_id != $2
ORDER BY
    CASE WHEN role = 'admin' THEN 0 ELSE 1 END,
    joined_at ASC
LIMIT 1
`

type GetFirstAdminOrMemberParams struct {
	ConversationID uuid.UUID `db:"conversation_id" json:"conversation_id"`
	UserID         uuid.UUID `db:"user_id" json:"user_id"`
}

type GetFirstAdminOrMemberRow struct {
	UserID uuid.UUID  `db:"user_id" json:"user_id"`
	Role   MemberRole `db:"role" json:"role"`
}

func (q *Queries) GetFirstAdminOrMember(ctx context.Context, arg GetFirstAdminOrMemberParams) (GetFirstAdminOrMemberRow, error) {
	row := q.queryRow(ctx, q.getFirstAdminOrMemberStmt, getFirstAdminOrMember, arg.ConversationID, arg.UserID)
	var i GetFirstAdminOrMemberRow
	err := row.Scan(&i.UserID, &i.Role)
	return i, err
}

const getUserConversations = `-- name: GetUserConversations :many
SELECT c.id, c.is_group, c.name, c.created_by, c.created_at, c.updated_at FROM conversations c
JOIN conversation_members cm ON cm.conversation_id = c.id
WHERE cm.user_id = $1
ORDER BY c.updated_at DESC
LIMIT $2 OFFSET $3
`

type GetUserConversationsParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	Limit  int32     `db:"limit" json:"limit"`
	Offset int32     `db:"offset" json:"offset"`
}

func (q *Queries) GetUserConversations(ctx context.Context, arg GetUserConversationsParams) ([]Conversation, error) {
	rows, err := q.query(ctx, q.getUserConversationsStmt, getUserConversations, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Conversation
	for rows.Next() {
		var i Conversation
		if err := rows.Scan(
			&i.ID,
			&i.IsGroup,
			&i.Name,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeConversationMember = `-- name: RemoveConversationMember :exec
DELETE FROM conversation_members
WHERE conversation_id = $1 AND user_id = $2
`

type RemoveConversationMemberParams struct {
	ConversationID uuid.UUID `db:"conversation_id" json:"conversation_id"`
	UserID         uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) RemoveConversationMember(ctx context.Context, arg RemoveConversationMemberParams) error {
	_, err := q.exec(ctx, q.removeConversationMemberStmt, removeConversationMember, arg.ConversationID, arg.UserID)
	return err
}

const setMemberRole = `-- name: SetMemberRole :exec
UPDATE conversation_members
SET role = $3
WHERE conversation_id = $1 AND user_id = $2
`

type SetMemberRoleParams struct {
	ConversationID uuid.UUID  `db:"conversation_id" json:"conversation_id"`
	UserID         uuid.UUID  `db:"user_id" json:"user_id"`
	Role           MemberRole `db:"role" json:"role"`
}

func (q *Queries) SetMemberRole(ctx context.Context, arg SetMemberRoleParams) error {
	_, err := q.exec(ctx, q.setMemberRoleStmt, setMemberRole, arg.ConversationID, arg.UserID, arg.Role)
	return err
}

const updateConversationName = `-- name: UpdateConversationName :one
UPDATE conversations
SET name = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, is_group, name, created_by, created_at, updated_at
`

type UpdateConversationNameParams struct {
	ID   uuid.UUID      `db:"id" json:"id"`
	Name sql.NullString `db:"name" json:"name"`
}

func (q *Queries) UpdateConversationName(ctx context.Context, arg UpdateConversationNameParams) (Conversation, error) {
	row := q.queryRow(ctx, q.updateConversationNameStmt, updateConversationName, arg.ID, arg.Name)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.IsGroup,
		&i.Name,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateConversationTimestamp = `-- name: UpdateConversationTimestamp :exec
UPDATE conversations
SET updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateConversationTimestamp(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.updateConversationTimestampStmt, updateConversationTimestamp, id)
	return err
}

const updateLastRead = `-- name: UpdateLastRead :exec
UPDATE conversation_members
SET last_read_at = NOW()
WHERE conversation_id = $1 AND user_id = $2
`

type UpdateLastReadParams struct {
	ConversationID uuid.UUID `db:"conversation_id" json:"conversation_id"`
	UserID         uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateLastRead(ctx context.Context, arg UpdateLastReadParams) error {
	_, err := q.exec(ctx, q.updateLastReadStmt, updateLastRead, arg.ConversationID, arg.UserID)
	return err
}
