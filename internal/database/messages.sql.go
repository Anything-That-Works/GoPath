// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: messages.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (conversation_id, sender_id, content, file_id, reply_to_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, conversation_id, sender_id, content, file_id, reply_to_id, status, is_edited, deleted_at, created_at, updated_at
`

type CreateMessageParams struct {
	ConversationID uuid.UUID      `db:"conversation_id" json:"conversation_id"`
	SenderID       uuid.UUID      `db:"sender_id" json:"sender_id"`
	Content        sql.NullString `db:"content" json:"content"`
	FileID         uuid.NullUUID  `db:"file_id" json:"file_id"`
	ReplyToID      uuid.NullUUID  `db:"reply_to_id" json:"reply_to_id"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.queryRow(ctx, q.createMessageStmt, createMessage,
		arg.ConversationID,
		arg.SenderID,
		arg.Content,
		arg.FileID,
		arg.ReplyToID,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.SenderID,
		&i.Content,
		&i.FileID,
		&i.ReplyToID,
		&i.Status,
		&i.IsEdited,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const editMessage = `-- name: EditMessage :one
UPDATE messages
SET content = $2, is_edited = TRUE, updated_at = NOW()
WHERE id = $1 AND sender_id = $3 AND deleted_at IS NULL
RETURNING id, conversation_id, sender_id, content, file_id, reply_to_id, status, is_edited, deleted_at, created_at, updated_at
`

type EditMessageParams struct {
	ID       uuid.UUID      `db:"id" json:"id"`
	Content  sql.NullString `db:"content" json:"content"`
	SenderID uuid.UUID      `db:"sender_id" json:"sender_id"`
}

func (q *Queries) EditMessage(ctx context.Context, arg EditMessageParams) (Message, error) {
	row := q.queryRow(ctx, q.editMessageStmt, editMessage, arg.ID, arg.Content, arg.SenderID)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.SenderID,
		&i.Content,
		&i.FileID,
		&i.ReplyToID,
		&i.Status,
		&i.IsEdited,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMessageByID = `-- name: GetMessageByID :one
SELECT id, conversation_id, sender_id, content, file_id, reply_to_id, status, is_edited, deleted_at, created_at, updated_at FROM messages WHERE id = $1
`

func (q *Queries) GetMessageByID(ctx context.Context, id uuid.UUID) (Message, error) {
	row := q.queryRow(ctx, q.getMessageByIDStmt, getMessageByID, id)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.SenderID,
		&i.Content,
		&i.FileID,
		&i.ReplyToID,
		&i.Status,
		&i.IsEdited,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMessageReceipts = `-- name: GetMessageReceipts :many
SELECT message_id, user_id, delivered_at, read_at FROM message_receipts WHERE message_id = $1
`

func (q *Queries) GetMessageReceipts(ctx context.Context, messageID uuid.UUID) ([]MessageReceipt, error) {
	rows, err := q.query(ctx, q.getMessageReceiptsStmt, getMessageReceipts, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessageReceipt
	for rows.Next() {
		var i MessageReceipt
		if err := rows.Scan(
			&i.MessageID,
			&i.UserID,
			&i.DeliveredAt,
			&i.ReadAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesByConversation = `-- name: GetMessagesByConversation :many
SELECT id, conversation_id, sender_id, content, file_id, reply_to_id, status, is_edited, deleted_at, created_at, updated_at FROM messages
WHERE conversation_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetMessagesByConversationParams struct {
	ConversationID uuid.UUID `db:"conversation_id" json:"conversation_id"`
	Limit          int32     `db:"limit" json:"limit"`
	Offset         int32     `db:"offset" json:"offset"`
}

func (q *Queries) GetMessagesByConversation(ctx context.Context, arg GetMessagesByConversationParams) ([]Message, error) {
	rows, err := q.query(ctx, q.getMessagesByConversationStmt, getMessagesByConversation, arg.ConversationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SenderID,
			&i.Content,
			&i.FileID,
			&i.ReplyToID,
			&i.Status,
			&i.IsEdited,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markMessageRead = `-- name: MarkMessageRead :exec
INSERT INTO message_receipts (message_id, user_id, read_at)
VALUES ($1, $2, NOW())
ON CONFLICT (message_id, user_id) DO UPDATE
SET read_at = NOW()
`

type MarkMessageReadParams struct {
	MessageID uuid.UUID `db:"message_id" json:"message_id"`
	UserID    uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) MarkMessageRead(ctx context.Context, arg MarkMessageReadParams) error {
	_, err := q.exec(ctx, q.markMessageReadStmt, markMessageRead, arg.MessageID, arg.UserID)
	return err
}

const softDeleteMessage = `-- name: SoftDeleteMessage :exec
UPDATE messages
SET deleted_at = NOW()
WHERE id = $1 AND sender_id = $2
`

type SoftDeleteMessageParams struct {
	ID       uuid.UUID `db:"id" json:"id"`
	SenderID uuid.UUID `db:"sender_id" json:"sender_id"`
}

func (q *Queries) SoftDeleteMessage(ctx context.Context, arg SoftDeleteMessageParams) error {
	_, err := q.exec(ctx, q.softDeleteMessageStmt, softDeleteMessage, arg.ID, arg.SenderID)
	return err
}

const upsertMessageReceipt = `-- name: UpsertMessageReceipt :exec
INSERT INTO message_receipts (message_id, user_id, delivered_at)
VALUES ($1, $2, NOW())
ON CONFLICT (message_id, user_id) DO UPDATE
SET delivered_at = COALESCE(message_receipts.delivered_at, NOW())
`

type UpsertMessageReceiptParams struct {
	MessageID uuid.UUID `db:"message_id" json:"message_id"`
	UserID    uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) UpsertMessageReceipt(ctx context.Context, arg UpsertMessageReceiptParams) error {
	_, err := q.exec(ctx, q.upsertMessageReceiptStmt, upsertMessageReceipt, arg.MessageID, arg.UserID)
	return err
}
